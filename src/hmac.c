#include <stdlib.h>
#include <string.h>

#include "hmac.h"
#include "bytes.h"

static const byte ipad[] = {
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};

static const byte opad[] = {
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c
};

void hmac_init(hmac_ctx *ctx, const hash_defn *defn,
               const byte *key, uint keylen)
{
  byte ikey[HASH_MAX_BLOCKLEN];

  ctx->hash_defn = defn;
  defn->init(&ctx->hash_ctx);

  if (keylen > defn->blocklen) {
    defn->digest(key, keylen, ctx->key);
    memset(ctx->key + defn->hashlen, 0, defn->blocklen - defn->hashlen);
  } else {
    memcpy(ctx->key, key, keylen);
    memset(ctx->key + keylen, 0, defn->blocklen - keylen);
  }

  bytes_xor(ikey, ctx->key, ipad, defn->blocklen);
  defn->update(&ctx->hash_ctx, ikey, defn->blocklen);
}

hmac_ctx *hmac_new(const hash_defn *defn, const byte *key, uint keylen)
{
  hmac_ctx *ctx;
  ctx = malloc(sizeof *ctx);
  hmac_init(ctx, defn, key, keylen);
  return ctx;
}

void hmac_update(hmac_ctx *ctx, const byte *m, uint mlen)
{
  ctx->hash_defn->update(&ctx->hash_ctx, m, mlen);
}

void hmac_final(hmac_ctx *ctx, byte *h)
{
  byte okey[HASH_MAX_BLOCKLEN];

  bytes_xor(okey, ctx->key, opad, ctx->hash_defn->blocklen);

  ctx->hash_defn->final(&ctx->hash_ctx, h);
  ctx->hash_defn->init(&ctx->hash_ctx);
  ctx->hash_defn->update(&ctx->hash_ctx, okey, ctx->hash_defn->blocklen);
  ctx->hash_defn->update(&ctx->hash_ctx, h, ctx->hash_defn->hashlen);
  ctx->hash_defn->final(&ctx->hash_ctx, h);
}

void hmac_digest(const hash_defn *defn, const byte *key, uint keylen,
                 const byte *m, uint mlen, byte *h)
{
  hmac_ctx ctx;
  hmac_init(&ctx, defn, key, keylen);
  hmac_update(&ctx, m, mlen);
  hmac_final(&ctx, h);
}
